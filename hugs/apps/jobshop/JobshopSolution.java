package hugs.apps.jobshop;

import hugs.*;
import java.util.*;
import hugs.support.*;
import java.io.*;

/**
* jobshop/data/jobshopSchedule.java
* Generated by the IDL-to-Java compiler (portable), version "3.0"
* from jobshop.idl
* Thursday, August 30, 2001 11:26:14 AM EDT
*/

public final class JobshopSolution implements Solution
{

  public int start[][] = null;
   public int critPath[][] = null;
   public int machSeq[][] = null; // machIdx[m][i] = is the job # of the ith
   // operation scheduled on machine m
   private int machineNindex2id[][];
   public int machIdx[][] = null;  // machIdx[j][i] = index of ith operation of
   // jth job on machine that it is scheduled on.

   public JobshopProblem problem;

   public JobshopSolution (JobshopProblem problem, int[][] _start,
                       int[][] _critPath, int[][] _machSeq, int[][] _machIdx)
  {
     this.problem = problem;
     start = _start;
     critPath = _critPath;
     machSeq = _machSeq;
     machIdx = _machIdx;
     machineNindex2id = new int[problem.machineCount][problem.jobCount];
     for (int j = 0; j < problem.jobCount; j++) 
        for (int o = 0; o < problem.machineCount; o++) {
           int index = machIdx[j][o];
           int id = problem.jobNop2id(j,o);
           int machine = problem.machine[j][o];
           machineNindex2id[machine][index] = id;
        }
  } // ctor

   public Solution copy () {
      return jobshopScheduleOps.copy(this);
   }

   public int size () {
      return problem.size();
   }
   

   public Score getScore () {
      if ( score == null ) return computeScore();
      return score;
   }

   public String toString () {
      return "[jobshop: " + score + "]";
   }
   private Score score = null;
   /// private IntScore score = null;

    public Score computeScore (SearchAdjuster adjuster, 
			       java.util.List marked)  {
	int unpacked = jobshopScheduleOps.repack(this);
	score = new JobshopScore(this,unpacked,(JobshopSearchAdjuster)adjuster,marked);
	return score;
    }
    
    public Score computeScore () {
	return computeScore(null,null);

   }

   public JobshopNode getNodeOnMachine (int machine, int index ) {
      int id = machineNindex2id[machine][index];
      return (JobshopNode) problem.getNodes()[id];
   }
   
   public int getPositionOnMachine (int i) {
      JobshopNode n = (JobshopNode) problem.getNodes()[i];
      return machIdx[n.getJob()][n.getOp()];
   }
   public void print () {
      System.out.println("Score: " + computeScore());
      for (int m = 0; m < problem.machineCount; m++) {
         for (int j = 0; j < problem.jobCount; j++)
            System.out.print( machSeq[m][j] + " ");
         System.out.println();
      }
   }

   public boolean insert (int selectJob, int selectOp, int selectMach, int insertOrd) {
      
            Vector seq = new Vector(problem.jobCount);
            operation movedJobOp = null;
            // Move the selected op to the new ordinal location:
            // System.out.println("Moving job"+selectJob + "op"+selectOp);
            for (int mIdx=0; mIdx<problem.jobCount; mIdx++)
            {
                // Find the op# for this job on this machine:
                int op;
                for (op=0; op<problem.machineCount; op++)
                    if (problem.machine[machSeq[selectMach][mIdx]][op] == selectMach)
                        break;
                // Now that we know the job&op, build a list:
                if (machSeq[selectMach][mIdx] == selectJob)
                {
                   // System.out.println(" "+mIdx+" Skipping job"+selectJob + "op"+op);
                    movedJobOp = new operation(selectJob, op);
                }
                else
                {
                   // System.out.println(" "+mIdx+" Adding job"+machSeq[selectMach][mIdx] + "op"+op);
                    seq.add(new operation(machSeq[selectMach][mIdx], op));
                }
            }
            // Add in moved one at new location:
            // System.out.println("   Inserting job"+movedJobOp.job+ "op"+movedJobOp.op+" @ "+insertOrd);
            seq.insertElementAt(movedJobOp, insertOrd);
            // change it back into an array:
            for (int mIdx=0; mIdx<problem.jobCount; mIdx++)
            {
               int job = ((operation)(seq.get(mIdx))).job;
               int op = ((operation)(seq.get(mIdx))).op;
               machSeq[selectMach][mIdx] = job;
               machIdx[job][op] = mIdx;
               machineNindex2id[selectMach][mIdx] = problem.jobNop2id(job,op);
            }

            return true;
   }

    public void precompute () {} 
} // class jobshopSchedule





