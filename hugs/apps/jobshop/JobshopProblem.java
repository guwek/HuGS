package hugs.apps.jobshop;

import hugs.*;
import hugs.support.*;
import hugs.utils.*;
import java.io.*;

/**
* jobshop/data/jobshopSchedule.java
* Generated by the IDL-to-Java compiler (portable), version "3.0"
* from jobshop.idl
* Thursday, August 30, 2001 11:26:14 AM EDT
*/

public final class JobshopProblem implements Problem 
{
  public int machineCount = (int)0;
  public int jobCount = (int)0;
   public int machine[][] = null; // maps job and op to machine.
  public int start[][] = null;
  public int duration[][] = null;
  public int mobilities[][] = null;
  public int critPath[][] = null;
  public int machSeq[][] = null;
  public int machIdx[][] = null;

   private JobshopNode[] nodes = null;
   private JobshopSolution solution;
   private int[][] nodeTable;
   
  public JobshopProblem ()
  {
     System.out.println("BUG: should implement maxspan better");
  } // ctor

  public JobshopProblem (int _machineCount, int _jobCount, int[][] _machine, int[][] _start, int[][] _duration, int[][] _mobilities, int[][] _critPath, int[][] _machSeq, int[][] _machIdx)
  {
    machineCount = _machineCount;
    jobCount = _jobCount;
    machine = _machine;
    start = _start;
    duration = _duration;
    mobilities = _mobilities;
    critPath = _critPath;
    machSeq = _machSeq;
    machIdx = _machIdx;
    makeNodes();
  } // ctor

   public int getJobCount () { return jobCount; }
   public int getMachineCount () { return machineCount; }
   public int jobNop2id (int job, int op) {
      return nodeTable[job][op];
   }
   private void makeNodes () {
      nodes = new JobshopNode[jobCount * machineCount];
      nodeTable = new int[jobCount][machineCount];
      int count = 0;
      for (int j = 0; j < jobCount; j++)
         for (int m = 0; m < machineCount; m++) {
            nodes[count] = new JobshopNode(j,m, machine[j][m]);
            nodeTable[j][m] = count;
            count++;
         }
   }

   public void print () {
      System.out.println("machSeq" );
      for (int m = 0; m < machineCount; m++) {
         for (int j = 0; j < jobCount; j++)
            System.out.print( machSeq[m][j] );
         System.out.println();
      }
   }


   public Node[] getNodes () {
      if ( nodes == null )
         makeNodes();
      return nodes;
   }
   public int size () {
      if ( nodes == null ) {
         makeNodes();
         if ( nodes == null ) return 0;
      }
      return nodes.length;
   }
   public Solution getInitSolution(){
      if ( nodes == null ) makeNodes();
      if ( solution == null ) {
	  // solution = new JobshopSolution(this,start,critPath, machSeq,machIdx);
	  solution = bestMWLSchedule(1000);
	  System.out.println("@@best = " + solution.getScore());
         if (jobshopScheduleOps.repack(solution) != 0)
            System.out.println("ERROR: Bad repack!");
      }

      return solution;
   }

    public JobshopSolution bestMWLSchedule (int num) {
	JobshopSolution best = MWLSchedule();
	for (int i = 1; i< num; i++) {
	    JobshopSolution s = MWLSchedule();
	    if ( s.getScore().isBetter(best.getScore()) )
		best = s;
	}
	return best;
    }

    public JobshopSolution MWLSchedule() {
	int total = jobCount * machineCount;
	int[] jobs = new int[jobCount];
	double[] workLeft = new double[jobCount];
	for (int i = 0; i < jobCount; i++){
	    jobs[i] = 0;
	    // shouldn't have to do this every time
	    workLeft[i] = 0;
	    for (int j = 0; j < machineCount; j++)
		workLeft[i] += duration[i][j];
	}
	int[] machs = new int[machineCount];
	for (int i = 0; i < machineCount; i++)
	    machs[i] = 0;

	int[] order = Utils.sortByDoubles(workLeft,false);
	int[] weights = new int[jobCount];
	weights[0] = 1;
	int weight = 2;
	for (int i = 1; i < jobCount; i++){
	    weights[i] = weights[i-1] + weight;
	    weight = weight * 2;
	}
	int jobsLeft = jobCount ;
	int totalWeight = weights[jobsLeft-1];
	int[][] machSeq = new int[machineCount][jobCount];
	int[][] machIdx = new int[jobCount][machineCount];




  while (total > 0){
      int num = (int)((double)totalWeight*Utils.randomDouble());
      int index = 0;
      while ( weights[index] < num )
	  index++;
      int pick = order[index];
      int mach = machine[pick][jobs[pick]];
      // int id = pick*machineCount+jobs[pick];
      // machSeq[mach][machs[mach]] = id;
      machSeq[mach][machs[mach]] = pick;
      machIdx[pick][jobs[pick]] = machs[mach];

      workLeft[pick] -= duration[pick][jobs[pick]];

      if ( workLeft[pick] == 0 ){
	  for (int k = index; k < jobsLeft; k++)
	      if ( k < order.length-1)
		  order[k] = order[k+1];
	  jobsLeft--;
	  if ( jobsLeft > 0 )
	      totalWeight = weights[jobsLeft-1];
      }
      else {
	  while ( index > 0 && workLeft[pick] < workLeft[order[index-1]] ){
	      order[index] = order[index-1];
	      index--;
	  }
	  order[index] = pick;
      }
      jobs[pick]++;
      machs[mach]++;
      total--;
  }
  int[][] crit = new int[jobCount][machineCount];
  int[][] start = new int[jobCount][machineCount];
  JobshopSolution s = new JobshopSolution(this,start,crit,machSeq,machIdx);
  return s;
   }


} // class jobshopSchedule

